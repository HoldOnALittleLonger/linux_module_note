Linux Kernel Module Programming Guide

Chapter 1 : Hello,world
  a kernel module at least has two function :
    init_module
    cleanup_module

    init_module will be registered into kernel,
    cleanup_module will be called when module exit,and clean up(undo) all things what init_module did.

  hello world :
    #include<linux/kernel.h>
    #include<linux/module.h>
    #include<linux/init.h>
    
    MODULE_LICENSE("GPL");
    MODULE_VERSION("v0.1");
    MODULE_AUTHOR("who");
    MODULE_DESCRIPTION("description");

    int __init init_module(void)
    {
            printk(KERN_INFO "hello world!");
	    return 0;
    }

    void __exit cleanup_module(void) {}

    module_init(init_module);
    module_exit(cleanup_module);

  /*  in the older kernel version,init_module() and cleanup_module() will as the entrance and the
   *  exit of module.
   *  now,use kernel function module_init() to register an init function of module,
   *  use kernel function module_exit() to register an exit function of module.
   */

  Makefile for kernel module :
    because kernel module is  not an independent executable,but an object file which will be linked into the
    kernel in runtime.
    so the gcc option "-c" is necessary.

    MODCFLAGS :
      __KERNEL__
        tell the header files that this code will be run in kernel mode,not as part of a user process.
      MODULE
        thell the header files to give the appropriate definitions for a kernel module.
      LINUX
        conditional compilation on the parts which are OS dependent.

    the certain flags in header config.h,kernel was compiled with these flags.

  Multiple file kernel modules :
    1>  in all the source files but one,add the macro definition "#define __NO_VERSION__"
    	normally,"module.h" use global variable "kernel_version" to record what is the kerne version this
	module compiled for.
	in the case of __NO_VERSION__ was defined,"module.h" wont include the header <version.h>.

    2>  compile all the source files as usual.

    3>  combine all object files into a single one.
    	execute linker with the command
	"ld -m elf_i386 -r -o <name of module>.o <1st source file>.o <2nd source file>.o ..."

  /*  this is the old way to compile kernel module.currently,for compile kernel module,should use the
   *  kernel Makefile which is in the path /lib/modules/`uname -r`/build .
   */

  the example of Makefile for a kernel module :
    context :
      
      obj-m += <kernel module name>.o
      <kernal module name>-objs += <1st dependence>.o ...
      <kernal module name>-objs += <Xth dependence>.o ...
      KBUILD_CFLAGS += <flags>
      ...

      all:
          make -C /lib/modules/`uname -r`/build M=$(PWD) module
      
      clean:
          make -C /lib/modules/`uname -r`/build M=$(PWD) clean


Chapter 2 : Character Device Files
  kernel module has two major ways to talk with processes.
  one :
    through device files(/dev).
  two :
    through proc file system.

  device file is generated for processes let they are able to communicate with device drivers in the kernel,
  through driver to communicate with physical devices.
  each device driver which is responsible for some type of hardware,and assigned its own major number.

  the file /proc/devices listed drivers and their major numbers,each physical device managed by a device driver
  is assigned a minor number.

  major number : type of hardware.
  minor number : physical device is managed by the device driver.
  

  mknod :
    create a device node.
  
  block devices have a buffer for requests,they can choose which order to respond.
  block devices can only accept input and return output in blocks.

  character devices and byte stream is alike,they can read any size of bytes and output as same.

  what action to taken when a file is opened and requsted to do something have to through file_operation struct.
  device file as same as use the file_operation struct to manipulate it.
  if the device file is opened by some processes,have to prevent remove the module from kernel,because if ejected
  it,but process calls the code in the old address registered by the kernel module,and it had been ejected,another
  module code is installed into that address,then wrong is ocurred.

  if the kernel module's reference count is not zero,then can not remove it from kernel.
  the variable mod_use_count_ is used to record how many objects is using this module.
  macro : MOD_INC_USE_COUNT , MOD_DEC_USE_COUNT can access that variable.
  
  in 2.6 kernel,module dont have to manage reference count by itself,new interfaces had been added.
  <linux/module.h>
    int try_module_get(struct module *);       //  inc module reference count
    void module_put(struct module *module);    //  dec module reference count

    struct module *find_module(const char *name);
    unsigned int module_refcount(struct module *mod);

      find a module via module @name.
      retrive module reference count via module pointer.

    struct module;
      this struct represent the module in kernel.


  LINUX_VERSION_NUMBER  -  current kernel version value.
  KERNEL_VERSION()      -  macro function to compute the kernel version value.
  			   for the special kernel version a.b.c
			   this function returns (2^16) * a + (2^8) * b + c

  <linux/fs.h>
    int __register_chrdev(unsigned int major, unsigned int baseminor, unsigned int count,
    			  const char *name, const struct file_operations *fops);
    void __unregister_chrdev(unsigned int major, unsigned int baseminor, unsigned int cout,
    	 	             const char *name);

      __register_chrdev is used to register a character device,__unregister_chrdev is used to unregister device.
      @major is major number
      @baseminor is the first of the range of minor numbers
      @count is the number of minor numbers required or the minor number the device is occupying
      @name is the name in /dev
      @fops is the associated file operations.

    /*  object-oriented file operations  */
    struct file_operations {
    	   ...
      	   ssize_t (*read) (struct file*, char __user *, size_t, loff_t *);
      	   ssize_t (*write) (struct file*, const char __user *, size_t, loff_t *);
      	   int (*open) (struct inode *, struct file *);
      	   int (*release) (struct inode *, struct file *);
	   ...
    };

  the method to get device's minor number in the case several physical device using the driver :
    inode.i_rdev & 0xFF

  !  must use preprocessing macro to compate older kernel


Chapter 3 : The /proc File System
  the another kernel modules to send information to processes is the /proc file system.
  proc register dynamic is allow kernel to determine what inode the file to use.
  for create a file in /proc,have to define a structure which contains all informations 
  needed by /proc file system.

  the structure saved informations needed by /proc is defined in header <linux/proc_fs.h>.

  typedef int (read_proc_t)(char *page, char **start, off_t off, int count, int *eof,
  	      		    void *data);
  typedef int (write_proc_t)(struct file *file, const char __user *buffer, unsigned long count,
  	      		     void *data);
  struct proc_dir_entry {
  	 unsigned int low_ino;  /*  lower inode number,0 means dynamic  */
  	 ...
	 uid_t uid;
	 gid_t gid;
	 loff_t size;
	 const struct inode_operations *proc_iops;
	 const struct file_operations *proc_fops;
	 ...
	 read_proc_t *read_proc;
	 write_proc_t *write_proc;
	 atomic_t count;
	 ....
  };
  /*  read_proc will be called by __proc_file_read(),this function is called by proc_file_read().
   *  and function proc_file_read() is the default method in proc_fops for reading.
   *  write_proc will be called by proc_file_write(),this function is the default method in proc_fops for
   *  writing.
   *  function create_proc_read_entry() receives a read_proc object,and sets it to proc_dir_entry.read_proc.
   *  read_proc and write_proc are the user-defined routines for read or write proc file,but of course,
   *  client have not to use the default functions to read or write proc files.
   */

  as usually,the global variable proc_root is the root dentry /proc .
  in the kernel 2.6.34, proc_regiser and proc_unregister primitives becomes static function in
  fs/proc/generic.c ,for register proc entry,have to use these functions :

    struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode, struct proc_dir_entry *parent);
    void remove_proc_entry(const char *name, struct proc_dir_entry *parent);
    struct proc_dir_entry *proc_create_data(const char *name, mode_t mode, struct proc_dir_entry *parent,
    	   		  		    const struct file_operations *proc_fops, void *data);

    /*  proc_create_data() will sets proc_dir_entry.data = data, proc_dir_entry.proc_fops = proc_fops  */
  
  create proc_dir_entry object when module is initializing,and remove the proc_dir_entry object when module
  is exiting.


Chapter 4 : Using /proc For Input
  for create a proc directory entry,have to use struct proc_dir_entry to represent the object.
  but it do not contain write function,because /proc is used to report kernel situation to processes.
  there is a way to allow write /proc file entry that is use filesystem mechanism.

  <linux/fs.h>
  struct inode_operations;
  struct file_operations;

    inode_operations contains all the functions kernel vfs aksed the filesystem have to implements.
    these operations is used to manipulate inode object.
    file_operations is same as inode_operations,but these operations is used to manipulate file object.
      (the different between the two is that file operations deal with the file itself,and inode operations
       deal with ways of referencing the file,such as creating links to it.)

  so the special proc_iops and proc_fops members allow to write /proc/entry.

  but have to notice read functions are used for output,write functions are used for input,the reason is
  that read and write refer to the user's point of view - if a process reads something from the kernel,
  then kernel needs to output it,and if a process writes something to the kernel,then kernel receives
  it as input.

  another point have to notice,that is,kernel land and user land has different memory area.
  a lot of kernel function just manipulate kernel memory not userland memory.
  for example :
    vfs_read() function will checks where the @buffer from.
    __user compiler attribute required the memory this pointer points to should be a userland memory,
    vfs_read() will checks if that true.

    function set_fs() and get_fs() are used to change memory segment checking behavior.
    there has two possible value :
      KERNEL_DS
      USER_DS

      KERNEL_DS disable userland memory segment checking in kernel land.
      USER_DS enable userland memory segment checking in kernel land.

      /*  these function is declared in <asm/uaccess.h>  */

  function copy_to_user() is used to output something to userland,@buffer have to be a pointer points to
  userland memory segment.
  function copy_from_user() is used to input something from userland,@buffer have to be a pointer points to
  userland memory segment.


Chapter 5 : Talking to Device Files (writes and IOCTLs)
  almost device drivers has been implemented ioctl function,client can use ioctl function to make 
  communication with devices.
  the entry under /dev is known as device file,and it is supposed to represent physical device.
  open a device file and read from it is input,
  open a device file and write to it is output.
  but more useful method is use ioctl function.

  generally,ioctl() is called with three parameters :
    1>  the file descriptor of the appropriate device file
    2>  the ioctl number
    3>  a parameter which is of type long

    @ioctl_number encodes the major device number,the type of the ioctl,the command,and the type of the @parameter.
    when add a new ioctl into kernel,have to use the macros defined in <linux/ioctl.h> :
      _IO     an ioctl with no parameters
      _IOW    an ioctl with write parameters  (copy_from_user)
      _IOR    an ioctl with read parameters   (copy_to_user)
      _IOWR   an ioctl with both write and read parameters 

      @first_arg for these macros is an identify letter or number from the table(defined in Documentation/ioctl/ioctl-number.txt)
      @second_arg for these macros is a sequence number
      @third_arg for these macros is the type of the data going into the kernel or coming out the kernel

  usage description :
    device file also has a file_operations structure is associated with it.
    file_operations.read represent the function used to read file
    file_operations.write represent the function used to write file
    file_operations.ioctl represent the function used to be called when process calls ioctl on it
    file_operations.open represent the function used to open file
    file_operations.close represent the function used to close file
    create a file_operations object,and associated it with a device file via __register_chardev(),
    now process under userland could calls ioctl() to communicate with the module(the device file).

    Steps :
      1>  define device_read()
      	    it is alike at generic file read function.
      2>  define device_write()
      	    it is alike at generic file write function.

      /*  have to notice that the @buffer is userland memory segment  */

      3>  define device_ioctl()
      	    if it supports several command(ioctl_number),then have to deal with all situation via
	    if expression or switch expression.
	    command matching have to use this form  _IO<What>(MAJOR_NUMBER, SEQUENCE_NUMBER, TYPE),
	    command macro is defined by _IO macros via different SEQUENCE_NUMBER and TYPE.

      /*  attention,the role for read is get something from outside(maybe just kernel land) and
       *  return to user process,
       *  the role for write is get something from user process and output.
       */

      4>  define device_open()
      	    similar to generic open.
      5>  define device_release()
      	    similar to generic close.

  /*  ioctl mechanism is too older,and too complicate for user process,so not recommend use it  */