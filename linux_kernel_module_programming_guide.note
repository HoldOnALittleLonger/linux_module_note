Linux Kernel Module Programming Guide

Chapter 1 : Hello,world
  a kernel module at least has two function :
    init_module
    cleanup_module

    init_module will be registered into kernel,
    cleanup_module will be called when module exit,and clean up(undo) all things what init_module did.

  hello world :
    #include<linux/kernel.h>
    #include<linux/module.h>
    #include<linux/init.h>
    
    MODULE_LICENSE("GPL");
    MODULE_VERSION("v0.1");
    MODULE_AUTHOR("who");
    MODULE_DESCRIPTION("description");

    int __init init_module(void)
    {
            printk(KERN_INFO "hello world!");
	    return 0;
    }

    void __exit cleanup_module(void) {}

    module_init(init_module);
    module_exit(cleanup_module);

  /*  in the older kernel version,init_module() and cleanup_module() will as the entrance and the
   *  exit of module.
   *  now,use kernel function module_init() to register an init function of module,
   *  use kernel function module_exit() to register an exit function of module.
   */

  Makefile for kernel module :
    because kernel module is  not an independent executable,but an object file which will be linked into the
    kernel in runtime.
    so the gcc option "-c" is necessary.

    MODCFLAGS :
      __KERNEL__
        tell the header files that this code will be run in kernel mode,not as part of a user process.
      MODULE
        thell the header files to give the appropriate definitions for a kernel module.
      LINUX
        conditional compilation on the parts which are OS dependent.

    the certain flags in header config.h,kernel was compiled with these flags.

  Multiple file kernel modules :
    1>  in all the source files but one,add the macro definition "#define __NO_VERSION__"
    	normally,"module.h" use global variable "kernel_version" to record what is the kerne version this
	module compiled for.
	in the case of __NO_VERSION__ was defined,"module.h" wont include the header <version.h>.

    2>  compile all the source files as usual.

    3>  combine all object files into a single one.
    	execute linker with the command
	"ld -m elf_i386 -r -o <name of module>.o <1st source file>.o <2nd source file>.o ..."

  /*  this is the old way to compile kernel module.currently,for compile kernel module,should use the
   *  kernel Makefile which is in the path /lib/modules/`uname -r`/build .
   */

  the example of Makefile for a kernel module :
    context :
      
      obj-m += <kernel module name>.o
      <kernal module name>-objs += <1st dependence>.o ...
      <kernal module name>-objs += <Xth dependence>.o ...
      KBUILD_CFLAGS += <flags>
      ...

      all:
          make -C /lib/modules/`uname -r`/build M=$(PWD) module
      
      clean:
          make -C /lib/modules/`uname -r`/build M=$(PWD) clean


Chapter 2 : Character Device Files
  kernel module has two major ways to talk with processes.
  one :
    through device files(/dev).
  two :
    through proc file system.

  device file is generated for processes let they are able to communicate with device drivers in the kernel,
  through driver to communicate with physical devices.
  each device driver which is responsible for some type of hardware,and assigned its own major number.

  the file /proc/devices listed drivers and their major numbers,each physical device managed by a device driver
  is assigned a minor number.

  major number : type of hardware.
  minor number : physical device is managed by the device driver.
  

  mknod :
    create a device node.
  
  block devices have a buffer for requests,they can choose which order to respond.
  block devices can only accept input and return output in blocks.

  character devices and byte stream is alike,they can read any size of bytes and output as same.

  what action to taken when a file is opened and requsted to do something have to through file_operation struct.
  device file as same as use the file_operation struct to manipulate it.
  if the device file is opened by some processes,have to prevent remove the module from kernel,because if ejected
  it,but process calls the code in the old address registered by the kernel module,and it had been ejected,another
  module code is installed into that address,then wrong is ocurred.

  if the kernel module's reference count is not zero,then can not remove it from kernel.
  the variable mod_use_count_ is used to record how many objects is using this module.
  macro : MOD_INC_USE_COUNT , MOD_DEC_USE_COUNT can access that variable.
  
  in 2.6 kernel,module dont have to manage reference count by itself,new interfaces had been added.
  <linux/module.h>
    int try_module_get(struct module *);       //  inc module reference count
    void module_put(struct module *module);    //  dec module reference count

    struct module *find_module(const char *name);
    unsigned int module_refcount(struct module *mod);

      find a module via module @name.
      retrive module reference count via module pointer.

    struct module;
      this struct represent the module in kernel.


  LINUX_VERSION_NUMBER  -  current kernel version value.
  KERNEL_VERSION()      -  macro function to compute the kernel version value.
  			   for the special kernel version a.b.c
			   this function returns (2^16) * a + (2^8) * b + c

  <linux/fs.h>
    int __register_chrdev(unsigned int major, unsigned int baseminor, unsigned int count,
    			  const char *name, const struct file_operations *fops);
    void __unregister_chrdev(unsigned int major, unsigned int baseminor, unsigned int cout,
    	 	             const char *name);

      __register_chrdev is used to register a character device,__unregister_chrdev is used to unregister device.
      @major is major number
      @baseminor is the first of the range of minor numbers
      @count is the number of minor numbers required or the minor number the device is occupying
      @name is the name in /dev
      @fops is the associated file operations.

    /*  object-oriented file operations  */
    struct file_operations {
    	   ...
      	   ssize_t (*read) (struct file*, char __user *, size_t, loff_t *);
      	   ssize_t (*write) (struct file*, const char __user *, size_t, loff_t *);
      	   int (*open) (struct inode *, struct file *);
      	   int (*release) (struct inode *, struct file *);
	   ...
    };

  the method to get device's minor number in the case several physical device using the driver :
    inode.i_rdev & 0xFF

  !  must use preprocessing macro to compate older kernel


Chapter 3 : The /proc File System
  the another kernel modules to send information to processes is the /proc file system.
  proc register dynamic is allow kernel to determine what inode the file to use.
  for create a file in /proc,have to define a structure which contains all informations 
  needed by /proc file system.

  the structure saved informations needed by /proc is defined in header <linux/proc_fs.h>.

  typedef int (read_proc_t)(char *page, char **start, off_t off, int count, int *eof,
  	      		    void *data);
  typedef int (write_proc_t)(struct file *file, const char __user *buffer, unsigned long count,
  	      		     void *data);
  struct proc_dir_entry {
  	 unsigned int low_ino;  /*  lower inode number,0 means dynamic  */
  	 ...
	 uid_t uid;
	 gid_t gid;
	 loff_t size;
	 const struct inode_operations *proc_iops;
	 const struct file_operations *proc_fops;
	 ...
	 read_proc_t *read_proc;
	 write_proc_t *write_proc;
	 atomic_t count;
	 ....
  };

  as usually,the global variable proc_root is the root dentry /proc .
  in the kernel 2.6.34, proc_regiser and proc_unregister primitives becomes static function in
  fs/proc/generic.c ,for register proc entry,have to use these functions :

    struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode, struct proc_dir_entry *parent);
    void remove_proc_entry(const char *name, struct proc_dir_entry *parent);
    struct proc_dir_entry *create_proc_data(const char *name, mode_t mode, struct proc_dir_entry *parent,
    	   		  		    const struct file_operations *proc_fops, void *data);
  
  create proc_dir_entry object when module is initializing,and remove the proc_dir_entry object when module
  is exiting.
